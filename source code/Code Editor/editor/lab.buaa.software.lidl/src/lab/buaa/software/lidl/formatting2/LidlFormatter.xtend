/*
 * generated by Xtext 2.25.0
 */
package lab.buaa.software.lidl.formatting2

import com.google.inject.Inject
import lab.buaa.software.lidl.lidl.LidlData
import lab.buaa.software.lidl.lidl.LidlProgram
import lab.buaa.software.lidl.services.LidlGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import lab.buaa.software.lidl.lidl.LidlImport
import lab.buaa.software.lidl.lidl.CompositeDataType
import lab.buaa.software.lidl.lidl.CompositeDataTypeElement
import lab.buaa.software.lidl.lidl.RefDataType
import lab.buaa.software.lidl.lidl.RefDataTypeElement
import lab.buaa.software.lidl.lidl.LidlInterface
import lab.buaa.software.lidl.lidl.LidlInteraction
import lab.buaa.software.lidl.lidl.LidlInteractionID
import lab.buaa.software.lidl.lidl.LidlParameter
import lab.buaa.software.lidl.lidl.AtomInterfaceType
import lab.buaa.software.lidl.lidl.AtomInterfaceTypeElement
import lab.buaa.software.lidl.lidl.CompositeInterfaceType
import lab.buaa.software.lidl.lidl.RefInterfaceType
import lab.buaa.software.lidl.lidl.RefInterfaceTypeElement

class LidlFormatter extends AbstractFormatter2 {

	@Inject extension LidlGrammarAccess

	/**
	 * LidlProgram
	 */
	def dispatch void format(LidlProgram prog, extension IFormattableDocument document) {
		// package part formatting
		if (prog.pack) {
			prog.regionFor.keyword(';').prepend[noSpace].append[setNewLines(2)]
		}

		// imports part formatting
		for (var i = 0; i < prog.imports.length - 1; i++) {
			prog.imports.get(i).format
		}
		// append a empty line after imports
		if (prog.imports.length > 0)
			prog.imports.get(prog.imports.length - 1).append[setNewLines(2)]

		// definitions part formatting
		for (lidlDefinition : prog.definitions) {
			lidlDefinition.format
		}
	}

	/**
	 * LidlImport
	 */
	def dispatch void format(LidlImport li, extension IFormattableDocument document) {
		// import decl formatting
		li.regionFor.keyword(';').prepend[noSpace].append[newLine]
	}

	/**
	 * LidlData 
	 */
	def dispatch void format(LidlData ld, extension IFormattableDocument document) {
		// data decl formatting
		val DATA_KEYWORD = ld.regionFor.keyword("data")
		val WITH_KEYWORD = if (ld.nested) {
				ld.regionFor.keyword("with")
			} else
				null
		val IS_KEYWORD = ld.regionFor.keyword("is")

		val openName = DATA_KEYWORD
		val closeName = if(ld.nested) WITH_KEYWORD else IS_KEYWORD

		// name part
		openName.append[newLine]
		interior(openName, closeName)[indent]
		closeName.prepend[newLine]

		// nested part
		if (ld.nested) {
			val openNested = WITH_KEYWORD
			val closeNested = IS_KEYWORD

			openNested.prepend[newLine].append[highPriority; newLine]
			interior(openNested, closeNested)[highPriority; indent]
			closeNested.prepend[newLine].append[highPriority; noSpace; newLine]
			for (nestedData : ld.nestedDef) {
				nestedData.format
			}
		} else {
			closeName.append[newLine]
		}

		// definition part
		ld.definition.format
	}

	/**
	 * CompositeDataType
	 */
	def dispatch void format(CompositeDataType cdt, extension IFormattableDocument document) {
		val open = cdt.regionFor.keyword('{')
		val close = cdt.regionFor.keyword('}')
		val cols = cdt.regionFor.keywords(',')

		if (cdt.items.length != 0) {
			open.prepend[newLine].append[newLine]
			interior(open, close)[indent]
			close.prepend[newLine]
			for (item : cdt.items) {
				item.format
			}
			for (col : cols) {
				col.prepend[noSpace].append[newLine]
			}
		} else {
			open.prepend[oneSpace].append[oneSpace]
			for (item : cdt.items) {
				item.format
			}
			for (col : cols) {
				col.prepend[noSpace].append[oneSpace]
			}
			close.prepend[oneSpace]
		}

		close.append[setNewLines(2)]
	}

	/**
	 * CompositeDataTypeElement
	 */
	def dispatch void format(CompositeDataTypeElement cdte, extension IFormattableDocument document) {
		val open = cdte.regionFor.keyword(':')
		open.prepend[noSpace].append[oneSpace]
	}

	/**
	 * RefDataType
	 */
	def dispatch void format(RefDataType rdt, extension IFormattableDocument document) {
		for (item : rdt.items) {
			item.format
		}
	}

	/**
	 * RefDataTypeElement
	 */
	def dispatch void format(RefDataTypeElement rdte, extension IFormattableDocument document) {
		val end = rdte.regionFor.assignment(getRefDataTypeElementAccess.getTypeAssignment_0_1)
		end.prepend[newLine].surround[indent].append[noSpace].append[setNewLines(2)]
	}

	/**
	 * LidlInterface
	 */
	def dispatch void format(LidlInterface li, extension IFormattableDocument document) {
		// interface keyword part
		val INTERFACE_KEYWORD = li.regionFor.keyword("interface")
		val WITH_KEYWORD = if (li.nested) {
				li.regionFor.keyword("with")
			} else
				null
		val IS_KEYWORD = li.regionFor.keyword("is")

		val openName = INTERFACE_KEYWORD
		val closeName = if(li.nested) WITH_KEYWORD else IS_KEYWORD

		// name part
		openName.append[newLine]
		interior(openName, closeName)[indent]
		closeName.prepend[newLine]

		// nested part
		if (li.nested) {
			val openNested = WITH_KEYWORD
			val closeNested = IS_KEYWORD

			openNested.prepend[newLine].append[highPriority; newLine]
			interior(openNested, closeNested)[highPriority; indent]
			closeNested.prepend[newLine].append[highPriority; noSpace; newLine]
		}

		for (nestedInterface : li.nestedDef) {
			nestedInterface.format
		}

		// definition part
		singleLine = false
		li.definition.format
	}

	/**
	 * LidlInteraction
	 */
	def dispatch void format(LidlInteraction li, extension IFormattableDocument document) {
		// interface keyword part
		val INTERACTION_KEYWORD = li.regionFor.keyword("interaction")
		val WITH_KEYWORD = if (li.nested) {
				li.regionFor.keyword("with")
			} else
				null
		val IS_KEYWORD = li.regionFor.keyword("is")
		val COL_KEYWORD = li.regionFor.keyword(":")
		val LEFT_KEYWORD = li.regionFor.keyword("(")
		val RIGHT_KEYWORD = li.regionFor.keyword(")")

		val openName = INTERACTION_KEYWORD
		val closeName = if(li.nested) WITH_KEYWORD else IS_KEYWORD

		// name part
		openName.append[newLine]
		interior(openName, closeName)[indent]
		closeName.prepend[newLine]

		li.id.format
		COL_KEYWORD.append[oneSpace].prepend[noSpace]
		singleLine = true
		li.interface.format
		singleLine = false

		// nested part
		if (li.nested) {
			val openNested = WITH_KEYWORD
			val closeNested = IS_KEYWORD

			openNested.prepend[newLine].append[highPriority; newLine]
			interior(openNested, closeNested)[highPriority; indent]
			closeNested.prepend[newLine].append[highPriority; noSpace; newLine]
		}

		for (nestedInteraction : li.nestedDef) {
			nestedInteraction.format
		}

		val left = LEFT_KEYWORD
		val right = RIGHT_KEYWORD

		left.prepend[newLine].append[newLine]
		interior(left, right)[indent]
		right.prepend[newLine].append[setNewLines(2)]

		// definition part
		li.definition.format
	}

	def dispatch void format(LidlInteractionID liid, extension IFormattableDocument document) {
		for (part : liid.items) {
			part.format
		}
	}

	def dispatch void format(LidlParameter lp, extension IFormattableDocument document) {
		val left = lp.regionFor.keyword("(")
		val right = lp.regionFor.keyword(")")
		val col = lp.regionFor.keyword(':')

		left.append[noSpace]
		right.prepend[noSpace]
		col.append[oneSpace].prepend[noSpace]
	}

	protected boolean singleLine = false

	def dispatch void format(AtomInterfaceType ait, extension IFormattableDocument document) {
		ait.items.format
	}

	def dispatch void format(AtomInterfaceTypeElement aite, extension IFormattableDocument document) {
		val type = aite.regionFor.assignment(getAtomInterfaceTypeElementAccess.getTypeAssignment_1)
		val direction = aite.regionFor.assignment(getAtomInterfaceTypeElementAccess.getDirectionAssignment_2)

		if (singleLine) {
			type.surround[oneSpace]
		} else {
			type.prepend[newLine].surround[indent]
			direction.prepend[oneSpace].append[noSpace; setNewLines(2)]
		}

	}

	def dispatch void format(CompositeInterfaceType cit, extension IFormattableDocument document) {
		val open = cit.regionFor.keyword("{")
		val close = cit.regionFor.keyword("}")
		val coms = cit.regionFor.keywords(",")

		open.append[singleLine ? oneSpace : newLine]
		interior(open, close)[indent]
		close.prepend[singleLine ? oneSpace : newLine]
		for (com : coms) {
			com.append[singleLine ? oneSpace : newLine]
		}

		for (cite : cit.items) {
			cite.format
		}
	}

	def dispatch void format(RefInterfaceType rit, extension IFormattableDocument document) {
		rit.items.format
	}

	def dispatch void format(RefInterfaceTypeElement rite, extension IFormattableDocument document) {
		val type = rite.regionFor.assignment(getRefInterfaceTypeElementAccess.getTypeAssignment_1)
		type.surround[singleLine ? oneSpace : newLine]
	}
}
